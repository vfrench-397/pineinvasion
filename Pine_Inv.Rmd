---
title: "Pine_Invasion"
output: html_document
---

# Introduction 

Pine trees are one of the most widely invasive species in the world. Pines are planted for commercial forestry across the southern hemisphere, where they escape plantations and invade native vegetation, such as grasslands, shrublands, beech forests, and eucalypt forests. Pines co-invade with non-native ectomycorrhizal fungi that pave the way for invasions by dispersing beyond the plantation, thus enabling new pine seedlings to take hold beyond the plantation. However, the fungi that are able to disperse beyond the plantation are a very limited set of fungi, leading to greatly reduced mycorrhizal diversity associated with pine invasions. Pine invasions are not only associated with drastically altered fungal communities, but invasion into Australian eucalyptus forests are also associated with lower soil total nitrogen (N) and phosphorus (P), and higher soil carbon (C):N and C:P ratios. Because soil fungal communities can have large impacts on and be greatly impacted by soil nutrients, we sought to address whether unique soil fungal communities in Australian pine-invaded forests, pine plantations, and uninvaded eucalypt forests are linked to the soil nutrients in these three forest types. Here, we analyzed the fungal communities in each of these three forest types at two sites in Australia that each contained the three forest types. 5 soil samples were collected at each forest type and analyzed for total C, total N, and bulk P. In each sample, fungal DNA was extracted and the ITS region was sequenced with Illumina Miseq. We processed the DNA sequence data with the DADA2 pipeline and then linked fungal communities to soil total C, N, and P with a weighted gene correlation network analysis formatted for taxa abundance data instead of gene expression data. We found that total N was positively correlated with one module of genera and total P was negatively correlated with another module of genera. With this analysis, we identified key fungal genera that are associated with high N and low P. Furthermore, abundance of the genera associated with low P varied with forest type, indicating that changes in fungal communities with pine invasion are related to changes in soil nutrients with pine invasion. 


# Version Control 

R version 4.0.3 (2020-10-10)
WGCNA 1.70.3
flashClust 1.1.2
DESeq2 1.30.1
BiocManager 1.30.12
MCMC.OTU 1.0.10
pheatmap 1.0.12
dada2 1.18.0
ShortRead 1.48.0
ggplot2 3.3.3
phyloseq 1.34.0
Biostrings 2.58.0
data.table 1.14.0
datastorr 0.0.3
fungaltraits 0.0.3
FUNGuildR 0.2.0.9000
jsonlite 1.7.2

```{r, warning=FALSE, message=FALSE}
setwd("/project/bi594/Pine_invasion")

library(WGCNA)
library(flashClust)
library(DESeq2)
library(BiocManager)
library(MCMC.OTU)
library(pheatmap)
library(dada2)
library(ShortRead) 
library(ggplot2)
library(phyloseq)
library(Biostrings)
library(data.table)
library(datastorr)
library(fungaltraits)
library(FUNGuildR)
library(jsonlite)
```


# DADA2 Pipeline 

We start with our DADA2 analysis where we input Illumina-sequenced paired-end fastq files that have been demultiplexed by sample. We then run these files through this pipeline to create an amplicon sequence variant (ASV) table which tells us the number of times each unique sequence variant was observed in each sample. We can then assign taxonomy and fungal functional groups to the ASVs to observe fungal community structure in our soil samples. 

Create a variable of our FASTQ files as characters 
```{r}
path <- "/project/bi594/Pine_invasion/rawdata/" #creating variable for file location
fns <- list.files(path) #creates a character vector of FASTQ files in designated path 
```

## Trimming and Filtering 

We create and sort the samples. We then divide them into complementary forward (_R1) and reverse (_R2) reads and simplify sample names
```{r}
fastqs <- fns[grepl(".fastq.gz", fns)] #find all .fastq in fns
fastqs <- sort(fastqs) #sorting to ensure samples are in order for downstream analysis 
fnFs <- fastqs[grepl("_R1", fastqs)] 
fnRs <- fastqs[grepl("_R2", fastqs)]
sample.names <- sapply(strsplit(basename(fnFs), "_"), `[`, 1) #getting simple sample names; removing .fastq.gz from characters
```

We then specified the path to the forward and reverse fastq files
```{r}
fnFs <- file.path(path, fnFs) 
fnRs <- file.path(path, fnRs)
```

Plotting Quality profiles to determine truncLen cutoffs for filter and trimming
```{r}
plotQualityProfile(fnFs[c(1:9)])
plotQualityProfile(fnRs[c(1:9)])

```

Creating subdirectory and directing the filtered and trimmed sequences to the specified directory. We then applied the saved sample.names to the filtered sequences. 
```{r}
filt_path <- file.path(path, "trimmed")
if(!file_test("-d", filt_path)) dir.create(filt_path)
filtFs <- file.path(path, "Filtered", paste0(sample.names, "_F_filt.fastq.gz"))
filtRs <- file.path(path, "Filtered", paste0(sample.names, "_R_filt.fastq.gz"))
names(filtFs) <- sample.names
names(filtRs) <- sample.names
```

Checking for presence of primer sequence in order to account for it in filtering. 
```{r}
primerF<-grep("CTTGGTCATTTAGAGGAAGTAA", "RV238_S210_L001_R1_001.fastq.gz") #ITS1F forward primer
primerF
#integer(0) - primer was not found, has already been filtered! Also confirmed in the SCC terminal with grep function
primerR<-grep("GCTGCGTTCTTCATCGATGC", "RV238_S210_L001_R2_001.fastq.gz") #ITS4 reverse primer
primerR
#integer(0) - primer was not found, has already been filtered! Also confirmed in the SCC terminal with grep function
```

Filtering forward and reverse reads with predetermined quality cutoffs. TruncLen was set to 250 for forward reads and 200 for reverse reads based on the dropoff of quality below a quality score of 25, seen in the Quality Profile Plot. Every other parameter was set to the default argument. 
```{r}
out <- filterAndTrim(fnFs, filtFs, fnRs, filtRs, truncLen= c(250,200),
                     maxN=0, 
                     maxEE= c(2,2),
                     truncQ=2, 
                     rm.phix=TRUE,
                     compress=TRUE, multithread=FALSE) 
#Must filter reads together to prevent mis-match sorting that can affect merging of forward and reverse reads downstream

#Checking reads.in versus reads.out = Number of reads remaining after filtering with quality scores 
head(out)
tail(out)
```

## Learning Error Rates 

DADA2 was utilized to employ a parametric error model to determine the error rate of the amplicon dataset. We kept the standard max consistency of 30 to increase the number of cycles and allow for convergence.
```{r}
setDadaOpt(MAX_CONSIST=30) 
errF <- learnErrors(filtFs, multithread=TRUE)
errR <- learnErrors(filtRs, multithread=TRUE)
```

Sanity check: We want to visualize error rates and make sure they are following a negative correlation with quality scores
```{r, message=FALSE,warning= FALSE}
plotErrors(errF, nominalQ=TRUE)
plotErrors(errR, nominalQ=TRUE)
```
Our error rates look relatively okay, not strictly linear but definitely a negative correlation 

## Dereplicating Reads 

Reads were dereplicated into unique sequences and deseq objects were assigned to sample names
```{r}
derepFs <- derepFastq(filtFs, verbose=FALSE)
derepRs <- derepFastq(filtRs, verbose=FALSE)
names(derepFs) <-sample.names
names(derepRs) <-sample.names
```

## Inferring Sequence Variants 

Applying the joint sample inference algorithm (infers sample sequences exactly and resolves differences of as little as 1 nucleotide) to get a the real variants as a dada class object. We set the band size to 32 as is recommended for ITS2 data. 
```{r, message=FALSE,warning= FALSE, results='hide'}
setDadaOpt(BAND_SIZE=32) 
dadaFs <- dada(derepFs, err=errF, multithread=TRUE)
dadaRs <- dada(derepRs, err=errR, multithread=TRUE)

#Observing the dada class object by sample to identify number of sequence variants 
dadaFs[[1]]
dadaFs[[29]]
```

Denoised forward reads were aligned with reverse-compliment corresponding denoised reverse reads to obtain full sequences

```{r}
mergers <- mergePairs(dadaFs, filtFs, dadaRs, filtRs, verbose=FALSE)
```

Constructing a sequence table (higher resolution otu table) The sequence table is a matrix with rows corresponding to (and named by) the samples, and columns corresponding to (and named by) the sequence variants

```{r}
seqtab <- makeSequenceTable(mergers)
dim(seqtab) 
```

## Removing Chimeras 

Dada accounts for substitution and indel errors but does not remove chimeras. 
```{r}
seqtab.nochim <- removeBimeraDenovo(seqtab, method="consensus", multithread=TRUE, verbose=TRUE)
#Identified 16 bimeras out of 1871 input sequences
dim(seqtab.nochim)
table(nchar(getSequences(seqtab.nochim))) #distribution of sequence lengths 
sum(seqtab.nochim)/sum(seqtab) 

```
Chimeras account for less than 1% of merged sequence variants 

Writing the output of the original sequence table and the sequence table with chimeras removed

```{r, eval=FALSE}
write.csv(seqtab,file="pineinvasion_seqtab.csv")
write.csv(seqtab.nochim,file="pineinvasion_nochim.csv")
```

## Tracking Read Statistics

Producing a csv table output that allows us to track the read statistics throughout the pipeline. It displays the raw reads, how many reads were filtered, denoised, etc. The final number of reads is located under the nonchim column.
```{r}
getN <- function(x) sum(getUniques(x))
track <- cbind(out, sapply(dadaFs, getN), sapply(dadaFs, getN), rowSums(seqtab), rowSums(seqtab.nochim))
colnames(track) <- c("input", "filtered", "denoised", "merged", "tabled", "nonchim")
rownames(track) <- sample.names 
head(track)
```

Writing the track reads csv
```{r, eval=FALSE}
write.csv(track,file="ReadFilterStats_AllData_final.csv",row.names=TRUE,quote=FALSE)
```

## Assigning Taxonomy 

We assigned the taxonomy using the UNITE general release reference database for Fungi (https://unite.ut.ee/repository.php). This version was released April 2nd 2020. All arguments were kept at default. 
```{r, message=FALSE}
taxa <- assignTaxonomy(seqtab.nochim, "/project/bi594/Pine_invasion/sh_general_release_dynamic_s_04.02.2020.fasta", multithread=TRUE)
taxa.print <- taxa
rownames(taxa.print) <- NULL #this gets rid of the sequence column

```

Writing the taxa csv file and save reads for the downstream heatmap
```{r, eval=FALSE, results= 'hide'}
unname(head(taxa, 30))
unname(taxa)
taxa<- sub('...', '', taxa)
```
```{r, eval=FALSE}
write.csv(taxa, file="taxa.csv",row.name=TRUE,quote=FALSE)
saveRDS(seqtab.nochim, file="final_seqtab_nochim.rds")
saveRDS(taxa, file="final_taxa_blastCorrected.rds")
```


# Phyloseq 

Loading in the previously saved data files and the variable table for phyloseq
```{r, warning = FALSE, message= FALSE}
setwd("/project/bi594/Pine_invasion")
seqtab.nochim <- readRDS("final_seqtab_nochim.rds")
taxa <- readRDS("final_taxa_blastCorrected.rds")
samdf<-read.csv("variabletable_pi.csv", header = TRUE, sep = ',')
rownames(samdf) <- samdf$SAMPLE #making rownames the same as sample names in seq.nochim to merge in phyloseq
```

Constructing the phyloseq object

```{r}
ps <- phyloseq(otu_table(seqtab.nochim, taxa_are_rows=FALSE), 
               sample_names(samdf), 
               tax_table(taxa))
ps
```

## Generating Abundance Bar plot 

Selecting the Top 90 most abundant taxa
```{r}
top90 <- names(sort(taxa_sums(ps), decreasing=TRUE))[1:90]
ps.top90 <- transform_sample_counts(ps, function(OTU) OTU/sum(OTU))
ps.top90 <- prune_taxa(top90, ps.top90)
```

Write a csv for the phyloseq data to hold the taxa abundances per sample. This will be useful for contructing the downstream heatmap. 
```{r}
psz <- psmelt(ps)
psz90 <- psmelt(ps.top90)
```
```{r, eval=FALSE}
write.csv(psz, file="psz.csv")
write.csv(psz90, file="top90.csv")
```


Appending the meta-data to the phyloseq data 
```{r}
colnames(psz)[2] <- "SampleID" #rename the sample ID column so we can merge the two dataframes by this column
fulldf <- merge(psz, samdf, by="SampleID")
#do the same for the top 90 taxa
colnames(psz90)[2] <- "SampleID" #rename the sample ID column so we can merge the two dataframes by this column
fulldf90 <- merge(psz90, samdf, by="SampleID")
```

Generating the barplot of fungal abundance by forest type separated by Class
```{r, fig.width=12}
p <- ggplot(fulldf, aes(x = site_code, y=Abundance, fill=Class))+ 
  labs(x="Forest type", fill = "Class")
p + geom_bar(stat="identity", colour="black") +
  scale_x_discrete(labels=c('Invaded forest', 'Plantation', "Native forest"))
```


```{r, eval = FALSE}
ggsave("Abundance_Class.png", path = "/project/bi594/Pine_invasion/Figures/", width=10, height=6, dpi=300)
```

## Assigning Functional Groups 

Assigning functional groups from the Funguild database (https://github.com/brendanf/FUNGuildR)
```{r}
funguild_input<- data.frame(taxa)
funguild_input$OTU <- row.names(funguild_input)  
funguild_input$Taxonomy <- paste(funguild_input$Kingdom, funguild_input$Phylum, funguild_input$Class, funguild_input$Order, funguild_input$Family, funguild_input$Genus, funguild_input$Species, sep =';')
funguild_input<- subset(funguild_input, select=-c(Kingdom, Phylum, Class, Order, Family, Genus, Species))

guilds<- funguild_assign(funguild_input)
```

Then we add guild annotations onto the abundance data and generate another barplot of abundance by trophic mode
```{r}
fullguild<- merge(fulldf, guilds, by="OTU")

p2 <- ggplot(fullguild, aes(x = site_code, y=Abundance, fill=trophicMode))+ 
  labs(x="Forest type", fill = "Trophic Mode")
p2 + geom_bar(stat="identity", colour="black") +
  scale_x_discrete(labels=c('Invaded forest', 'Plantation', "Native forest"))
```

```{r, eval=FALSE}
ggsave("Abundance_Trophic.png", plot=p2, path = "/project/bi594/Pine_invasion/Figures/", width=10, height=6, dpi=300)
```

Here, we can see that the abundance of different functional guilds is different between forest types, which could have large impacts on nutrient cycling.

Collapsing taxonomy in OTU table for WGCNA input 
```{r}
#Collapse the data in the phyloseq object to genus-level IDs
glom <- tax_glom(ps, taxrank = 'Genus')
#Create a dataframe of the OTUs and taxonomic assignments at the genus level
otu<- data.frame(otu_table(glom))
tax_table <- data.frame(tax_table(glom))
#Replace the sequences in the OTU table with corresponding Genus-level IDs
Genus<- tax_table$Genus
colnames(otu) <- Genus
```

Write the OTU that will be used as the input for WGCNA
```{r, eval=FALSE}
write.csv(otu,file="otu.csv")
```

# Weighted Gene Correlation Network Analysis

Now that we've taken a look at our fungal community data, we'd like to know how the fungal communities relate to soil carbon (C), nitrogen (N), and phosphorus (P). To do this, we use a Weighted Gene Correlation Network Analysis (WGCNA) that will relate the abundance of the genera present in each sample to the C, N, and P of that sample. This analysis will indicate if certain genera are associated with certain soil C, N, and P conditions. 

Merging count data with Genus IDs and removing outlier samples. OTU cutoff was set really low so that most of the OTUs weren't purged.  
```{r, warning = FALSE, message= FALSE}
setwd("/project/bi594/Pine_invasion")
countData<-read.csv("otu.csv", stringsAsFactors = FALSE)
colnames(countData)[1] = "Sample_ID"

count.trim <- purgeOutliers(countData,count.columns=2:282, otu.cut= .000000000001)
```

Trimmed RV55 sample and a little under 230 taxa
```{r}
rownames(count.trim)=count.trim$cdat
count.trim$cdat <- NULL
class(count.trim)
```

Transposing data.frame into a matrix and changing column names to indicate the three forest types: Plantation, Invaded forest, and Native forest.  
```{r, results='hide'}
t<- t(as.data.frame(lapply(count.trim,as.numeric)))
colnames(t) <- rownames(count.trim)
class(t)

sapply(t, is.numeric)
ncol(t)
nrow(t)
colnames(t) = c("PL1.1", "PL1.2", "PL1.3", "PL1.4", "PL1.5", "UN1.1", "UN1.2", "UN1.3","UN1.4","UN1.5", "INV1.1", "INV1.2", "INV1.3", "INV1.4", "PL2.1", "PL2.2", "PL2.3", "PL2.4", "PL2.5", "UN2.1", "UN2.3", "UN2.4", "UN2.5", "INV2.1", "INV2.2", "INV2.3", "INV2.4", "INV2.5")
```

Reading in treatment data and inserting samples from purge outliers. 
```{r, message= FALSE, warning = FALSE}
setwd("/project/bi594/Pine_invasion")
samdf<- read.csv("variabletable_pi.csv")
rownames(samdf)[samdf$SampleID=='RV55'] 
samdf.trim <- samdf[-c(21),]
treat=samdf.trim$site_code
g=data.frame(treat)
```

Creating colData for DESeq.
```{r}
colData<- g
class(colData)
str(colData)
nrow(colData)
```

Running DeSeq to filter out very low counts

Constructing DESeqDataSet Object. 
```{r, message= FALSE, warning = FALSE}
dds<-DESeqDataSetFromMatrix(countData=t, colData=colData, design=~ treat) 
```

Calculating geometric means of the counts. Estimating size factors to get the relative library depth of the samples and running DESeq function. 
```{r, message= FALSE, warning = FALSE}
gm_mean = function(x, na.rm=TRUE){
  exp(sum(log(x[x > 0]), na.rm=na.rm) / length(x))
}
geoMeans = apply(counts(dds), 1, gm_mean)
dds = estimateSizeFactors(dds, geoMeans = geoMeans)
dds = DESeq(dds, fitType="local")
```

Transform the count data to the log2 scale in a way which minimizes differences between samples for rows with small counts. This normalizes with respect to library size. Also making a matrix of our rlog data. 
```{r, message= FALSE, warning = FALSE}
rld <- rlogTransformation(dds, blind=TRUE, fitType="local")
rld_wg=(assay(rld))
nrow(rld_wg)
```

Writing csv for transformed data to take into WGCNA. 
```{r, eval= FALSE}
write.csv(rld_wg,file="Invasion_wgcna_allgenes2.csv",quote=F,row.names=T)
```

Data input and cleaning. Transposing the expression data for further analysis.
```{r, warning = FALSE, message= FALSE}
options(stringsAsFactors=FALSE)
allowWGCNAThreads()

setwd("/project/bi594/Pine_invasion")
dat=read.csv("Invasion_wgcna_allgenes2.csv")
rownames(dat)<-dat$X
dat$X=NULL
names(dat)
nrow(dat)

datExpr0 = as.data.frame(t(dat))
```

Reading in trait data and matching the samples to the expression samples for which they were measured (linking things correctly). Also, inserting samples removed from purgeoutliers 
```{r, warning = FALSE, message= FALSE}
setwd("/project/bi594/Pine_invasion")
traitData= read.csv("Invasion_traits_WGCNA.csv")
rownames(traitData)[traitData$Sample_ID=='RV55'] 
trait.trim <- traitData[-c(21),]
rownames(trait.trim) <- trait.trim$Sample_ID
trait.trim$Sample_ID <- NULL
dim(trait.trim)
names(trait.trim)
```

Creating a data frame analogous to expression data that will hold the clinical traits. 
```{r}
dim(datExpr0)
rownames(datExpr0)
datTraits=trait.trim
row.names(datTraits)= c("PL1.1", "PL1.2", "PL1.3", "PL1.4", "PL1.5", "UN1.1", "UN1.2", "UN1.3","UN1.4","UN1.5", "INV1.1", "INV1.2", "INV1.3", "INV1.4", "PL2.1", "PL2.2", "PL2.3", "PL2.4", "PL2.5", "UN2.1", "UN2.3", "UN2.4", "UN2.5", "INV2.1", "INV2.2", "INV2.3", "INV2.4", "INV2.5")
```

Returns true indicating dataset is aligned correctly.
```{r}
table(rownames(datTraits)==rownames(datExpr0))
```

Clustering the samples by expression to create a sample dendogram and trait heatmap. First whole network connectivity was calculated and standardized. Trait colors converted such that red illustrates high values.
```{r}
A=adjacency(t(datExpr0))

k=as.numeric(apply(A,2,sum))-1
Z.k=scale(k)
thresholdZ.k=-2.5
outlierColor=ifelse(Z.k<thresholdZ.k,"red","black")

sampleTree = flashClust(as.dist(1-A), method = "average")

traitColors=data.frame(numbers2colors(datTraits,signed=FALSE))
dimnames(traitColors)[[2]]=paste(names(datTraits))
datColors=data.frame(outlierC=outlierColor,traitColors)
```

```{r message=FALSE, warning=FALSE, fig.cap= "**Figure X. Sample dendogram and trait heat map where red indicates high values. The first band indicates that there were no outliers. The following three bands depict soil percent nitrogen, percent carbon, and bulk phosphorus respectively.**"}
plotDendroAndColors(sampleTree,groupLabels=names(datColors), colors=datColors,main="Sample dendrogram and trait heatmap")
```
## Network Construction and Module Detection 

Setting our working environment and loading in previously saved expression and trait data. 
```{r, warning = FALSE, message= FALSE}
options(stringsAsFactors = FALSE)
setwd("/project/bi594/Pine_invasion")
lnames = load(file="Invasion_Samples_Traits_ALL2.RData")
```

## Determining the soft power threshold

The Soft power threshold is the power to which co-expression similarity is raised in order to calculate adjacency. It is standard (according to approximate scale-free topology criterion) to select a soft power threshold that corresponds to a scale free topology model fit (R^2) greater than 0.8. If the value of SFT.R.sq does not reach this threshold within a reasonable power (less than 15 for signed data) then the soft power threshold can be decided based on sample size. 

https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/faq.html

First we must set parameters for a set of cadidate soft-threshold powers to plot and visualize scale independence and mean connectivity. 
```{r}
#Standard setting 
powers = c(seq(1, 10, by = 1), seq(12, 20, by = 2))
#Producing SFT.R.sq way too small
```


```{r}
#adjusting power values just to see if .8 threshold could be reached (it cannot)
#powers = c(seq(100, 190,by=10), seq(200,250, by=5))
```

Plotting Scale Independence and Mean Connectivity to determine soft-power threshold based on the sclae free topology index and mean connectivity as functions of the soft power threshold. 
```{r, results='hide'}
# Call the network topology analysis function
sft = pickSoftThreshold(datExpr0, powerVector = powers, networkType="signed", verbose = 2)
```

```{r}
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers, col="red");
# this line corresponds to using an R^2 cut-off (want it to be between .8 and .9 when selecting sft)
abline(h=0.90,col="red")
```


```{r}
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, col="red")
```

Because our soft power thresholds never seem to be able to reach a signed R^2 of .8, we decide on the softpower threshold of 16 according to our sample size of 29. 
https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/faq.html

```{r}
softPower=16 
```

Then we will construct the adjacency matrix that will be utilized to create our initial dendrogram. The adjacency function calculates (correlation or distance) network adjacency from given expression data or from similarity. We want to use signed correlation (this is the default) because we want to create modules with similar abundance patterns for easier biological interpretation of the final output. 
```{r}
adjacency=adjacency(datExpr0, power=softPower,type="signed") 
```

## Create dendrogram
Now, we want to visualize how the genera group together based on their abundances across samples. For example, genera that regularly appear together in the same samples will cluster together.

We translate the adjacency into a topological overlap matrix and calculate the corresponding dissimilarity:
```{r, message=FALSE}
TOM= TOMsimilarity(adjacency,TOMType = "signed")
dissTOM= 1-TOM
```

Then, we create the tree that clusters genera together based on similarity in abundances. Each leaf corresponds to a genus, and branches grouping together densely are genera that frequently occur together. 
```{r}
library(flashClust)
geneTree= flashClust(as.dist(dissTOM), method="average") #do we want to change method back to default?
plot(geneTree, xlab="", sub="", main= "Gene Clustering on TOM-based dissimilarity", labels= FALSE,hang=0.04)
```

Next, we set the smallest number of genera that can be included in a module. We chose 5 because there are 281 genera, so higher than 5 would be a very high percentage of all genera. But, less than 5 would be too few genera to consider a cluster.   

```{r}
minModuleSize=5
dynamicMods= cutreeDynamic(dendro= geneTree, distM= dissTOM, deepSplit=2, pamRespectsDendro= FALSE, minClusterSize= minModuleSize)
table(dynamicMods)
```

From this table, we can see that we have 21 modules. 35 taxa were unable to be placed into a module.

Next, we assign colors to each module and plot the colors below the dendrogram to show which branches belong to which module. 

```{r}
dynamicColors= labels2colors(dynamicMods) #assigning colors to each module
plotDendroAndColors(geneTree, dynamicColors, "Dynamic Tree Cut", dendroLabels= FALSE, hang=0.03, addGuide= TRUE, guideHang= 0.05, main= "Gene dendrogram and module colors")
```

## Merge modules

Because some modules have similar genera abundance profiles, we want to merge those modules into one. With gene expression data, an eigengene is calculated for each module, which is a representative expression value for each module. We do the same here, except with abundances instead of gene expression values. 

```{r}
#calculate eigengenes
MEList= moduleEigengenes(datExpr0, colors= dynamicColors,softPower = 16)
MEs= MEList$eigengenes
#Calculate dissimilarity of module eigenegenes
MEDiss= 1-cor(MEs)
#Cluster module eigengenes
METree= flashClust(as.dist(MEDiss), method= "average")
```


We reload the saved data:
```{r, warning = FALSE, message= FALSE}
setwd("/project/bi594/Pine_invasion")
lnames <- load(file = "Network_invasion_0.7.RData")
```

Then, we plot a tree of the modules and add a line to show where we merge the modules. Any modules below the red line will be merged to the closest branch above the line. We chose 0.7 as the merging height because any value less than 0.7 resulted in many modules with similar abundance patterns. 

```{r}
plot(METree, main= "Clustering of module eigengenes", xlab= "", sub= "")

MEDissThres= 0.7 #*we can change the threshold of our height, merges them different based on value, dont want to overmerge things that arent that similar
abline(h=MEDissThres, col="red")
```

The below code executes the actual merging of modules. We then plot the same dendrogram as previously, but with an added annotation below showing the new modules and colors after merging. 

```{r, messages=FALSE}
merge= mergeCloseModules(datExpr0, dynamicColors, cutHeight= MEDissThres, verbose =1)

mergedColors= merge$colors
mergedMEs= merge$newMEs

plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors), c("Dynamic Tree Cut", "Merged dynamic"), dendroLabels= FALSE, hang=0.03, addGuide= TRUE, guideHang=0.05)

moduleColors= mergedColors
colorOrder= c("grey", standardColors(50)) #here we indicate that genera that cannot be assigned to a module are assigned the color grey 
moduleLabels= match(moduleColors, colorOrder)-1
MEs=mergedMEs

#save module colors and labels for use in subsequent parts
save(MEs, moduleLabels, moduleColors, geneTree, file= "Network_signed_0.7.RData")
```

## Relating modules to traits and finding important genes

The following setting is important, do not omit:
```{r}
options(stringsAsFactors = FALSE);
```

This code creates variables for the number of genera and the number of samples. Then we view a table of the module colors which shows how many genera are in each module.
```{r}
nGenes = ncol(datExpr0)
nSamples = nrow(datExpr0)
table(moduleColors)
```

Next, we recalculate the module eigengenes with color labels. 
```{r}
MEs0 = moduleEigengenes(datExpr0, moduleColors)$eigengenes
MEs = orderMEs(MEs0)
moduleTraitCor = cor(MEs, datTraits, use = "p");
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples);
```

### Module heatmap
Now, we want to relate our modules to our traits, which are soil total C, N, and P. To do this, we represent module trait correlations as a heatmap, where each row represents a module and each column represents a trait. If a module is significant for a particular trait, it will show a low p-value (usually significance is considered p<0.05, but because of our low sample size, we will consider p<0.1 to be significant for this assignment). Significance indicates that the genera present in that module are frequently associated with either a high or low value of that trait. 

```{r}
# Will display correlations and their p-values
textMatrix = paste(signif(moduleTraitCor, 2), "\n(",
                   signif(moduleTraitPvalue, 1), ")", sep = "");
dim(textMatrix) = dim(moduleTraitCor)
par(mar = c(6, 8.5, 3, 3));
# Display the correlation values within a heatmap plot
labeledHeatmap(Matrix = moduleTraitCor,
               xLabels = names(datTraits),
               yLabels = names(MEs),
               ySymbols = names(MEs),
               colorLabels = FALSE,
               colors = blueWhiteRed(50),
               textMatrix = textMatrix,
               setStdMargins = FALSE,
               cex.text = 0.5,
               zlim = c(-1,1),
               main = paste("Module-trait relationships"))
```
This heatmap looks good, because we can tell that we did not under-merge our modules. If we had not merged our modules enough, you would see blocks of modules next to each other that have similar profiles (for example, large chunks of blue or red modules together). The top number in each cell indicates the correlation between the module and the trait, and the number in parentheses below the correlation value is the p-value showing significance of the correlation. 

Here, we can see that the yellow module is significant for P, but negatively associated with P. In other words, genera in this module are frequently associated with low P. The midnight blue module is significant for C and N, where the genera in this module are frequently associated with high C and N. Additionally, P is positively associated with genera that could not be assigned to a module (grey). However, because of the difficulty to interpret significance of unassigned genera, we will not consider the grey module in this analysis. 

Next, we quantify associations of individual genera with our traits by defining (the absolute value of) the correlation between the genus and the trait. For each module, we also define module membership (MM), which is a measure of the correlation of the module eigengene and the genera abundance profile. The similarity of every genera to every module is quantified.

```{r}
weight = as.data.frame(datTraits$P); #Here, you can change to your trait of interest. We use soil P here.
names(weight) = "bulk P" 
# names (colors) of the modules
modNames = substring(names(MEs), 3)
geneModuleMembership = as.data.frame(cor(datExpr0, MEs, use = "p"));
MMPvalue = as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), nSamples));
names(geneModuleMembership) = paste("MM", modNames, sep="");
names(MMPvalue) = paste("p.MM", modNames, sep="");
geneTraitSignificance = as.data.frame(cor(datExpr0, weight, use = "p"));
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples));
names(geneTraitSignificance) = paste("GS.", names(weight), sep="");
names(GSPvalue) = paste("p.GS.", names(weight), sep="")
```

### Module correlation plot

To examine the correlation of the genera in a module to the trait of interest, we create a correlation plot with a module of interest on the x axis and the trait on the y axis. Here, we chose the yellow module with bulk P because the yellow module was significant for bulk P on our module heatmap. We can see in this plot that there is a positive correlation between the module and bulk P. 

```{r}
module = "yellow" #*change this to the module we're going to look at
column = match(module, modNames);
moduleGenes = moduleColors==module;
par(mfrow = c(1,1));
verboseScatterplot(abs(geneModuleMembership[moduleGenes, column]),
                   abs(geneTraitSignificance[moduleGenes, 1]),
                   xlab = paste("ModMem in", module, "module"),
                   ylab = "Sig for bulk P",
                   main = paste("MM vs. GS\n"),
                   cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2, col = module)
```

Making VSD files by module - so we can tell what genera are in each module

```{r}
# vs=t(datExpr0)
# cands=names(datExpr0[moduleColors=="yellow"]) #change this to the color of the module we're looking at
# #subsetting the genes in this module
# c.vsd=vs[rownames(vs) %in% cands,]
# head(c.vsd)
# nrow(c.vsd) #should correspond to module size
# table(moduleColors) #check module sizes here
# head(c.vsd)
# write.csv(c.vsd,"rlog_MMmidnightblue.csv",quote=F)
```

### Identify genera in each module and their kMEs

We now want to know which genera fit best into our module out of all the genera in the module. To do this, we calculate a kME score for all genera, which indicates how well each genus fits into each module. A higher kME indicates a better fit in the module. 
```{r, warning = FALSE, message= FALSE}
setwd("/project/bi594/Pine_invasion/")
vsd <- read.csv("Invasion_wgcna_allgenes2.csv", row.names=1)
options(stringsAsFactors=FALSE)
data=t(vsd)
allkME =as.data.frame(signedKME(data, MEs))

```

Then, we have to subset the genera in our module of interest from all of the genera. To do this, we first create a data frame for our module that lists all the genera and scores them as either belonging in the module ("1") or not belonging in the module ("0"). 

```{r}
whichModule="yellow"

length(moduleColors)
inModule=data.frame("module"=rep(0,nrow(vsd)))
row.names(inModule)=row.names(vsd)
genes=row.names(vsd)[moduleColors == whichModule]
inModule[genes,1]=1
sum(inModule[,1]) #this should be the same number of genera that was in the module
```

```{r, eval=FALSE}
write.csv(inModule,file=paste(whichModule,"_fisher.csv",sep=""),quote=F)
```

Now, we can extract a list of the genera in the module. 
```{r}
yellow <- subset(inModule, module=="1")
yellow <- row.names(yellow)
yellow
```


We then create a dataframe of the kMEs of all the genera for just our module of interest: 
```{r}
modColName=paste("kME",whichModule,sep="")
modkME=as.data.frame(allkME[,modColName])
row.names(modkME)=row.names(allkME)
names(modkME)=modColName

```
```{r, eval=FALSE}
write.csv(modkME,file=paste(whichModule,"_kME.csv",sep=""),quote=F)
```


From this dataframe, we then subset just the genera in our module of interest:
```{r}
ykmeinput<- paste(yellow, sep=",")
yellowkme<- subset(modkME, rownames(modkME) %in% ykmeinput)
Genus <- rownames(yellowkme)
rownames(yellowkme) <- NULL
yellowkme <- cbind(Genus,yellowkme)
```

And now, we can plot the kMEs of the genera in our module of interest to see which genera fit best into the module. 
```{r}
ggplot(data= yellowkme, aes(x=reorder(Genus, -kMEyellow), y=kMEyellow)) + 
  geom_bar(color= "black", fill="yellow", stat="identity") +
  theme(axis.text.x=element_text(angle=45,hjust=1,vjust=1)) +
  labs(x="Genus", y="kME")
```

We can conclude here that these genera are associated with low soil P, and may be drivers of low soil P. The genera with the highest kMEs may be key genera that are driving low soil P: *Meliniomyces*, *Leucosporidium*, and *Densospora*. 

### Heatmaps of module genera abundances by sample

To see how module genera abundances change between samples, we can create a heatmap showing the abundance of each genus in each sample.  
```{r}
which.module="yellow" #*change this also to the color of module we're looking at 
#pick module of interest
ME=MEs[, paste("ME",which.module, sep="")]
genes=datExpr0[,moduleColors==which.module ] #replace where says subgene below to plot all rather than just subset

#quartz()
# par(mfrow=c(2,1), mar=c(0.3, 5.5, 3, 2))
par(mfrow=c(2,1), mar=c(0.3, 5.5, 5, 2))
plotMat(t(scale(genes) ),nrgcols=30,rlabels=F, clabels=rownames(genes), rcols=which.module)
par(mar=c(5, 4.2, 0, 0.7))
barplot(ME, col=which.module, main="", cex.main=2,
        ylab="Eigengene abundances",xlab="sample")
```
**Figure X. Heatmap of genera abundances in each sample in the yellow module and eigengene abundance barplot.** Columns of the heatmap represent samples and rows represent each genus in the yellow module. Red indicates higher abundance of a genus and light green represents lower abundance. Higher bars in the barplot indicate higher abundances of genera in the yellow module in a given sample. 'PL' samples are from pine plantations, 'UN' samples are from uninvaded eucalypt forests adjacent to invaded forests, and 'INV' are from pine-invaded eucalypt forests.


While sample UN2.3 has much higher abundances of genera in the yellow module than all other samples, all samples from the invaded forest in site 2 have relatively high abundances of genera in the yellow module. This indicates that abundance of genera associated with low P varies across forest types.

To see how the abundance of module genera in each sample is associated with the soil P in each sample, we plot the same heatmap as before alongside a barplot of soil P in each sample.  
```{r}
which.module="yellow" #pick module of interest
which.trait="P" #change trait of interest here
datTraits=datTraits[order((datTraits$P),decreasing=T),]#change trait of interest here

trait=datTraits[, paste(which.trait)]
genes=datExpr0[,moduleColors==which.module ] #replace where says subgene below to plot all rather than just subset
genes=genes[rownames(datTraits),]

#quartz()
par(mfrow=c(2,1), mar=c(0.3, 5.5, 3, 2))
plotMat(t(scale(genes) ),nrgcols=30,rlabels=F, clabels=rownames(genes), rcols=which.module)
par(mar=c(5, 4.2, 0, 0.7))
barplot(trait, col=which.module, main="", cex.main=2,
        ylab="bulk P (ug/g)",xlab="sample")#change trait of interest here
```
**Figure X. Heatmap of genera abundances in each sample in the yellow module and barplot of bulk soil P.** Columns of the heatmap represent samples and rows represent each genus in the yellow module. Red indicates higher abundance of a genus and light green represents lower abundance. Increasing values on the y-axis of the barplot indicate more bulk P in a soil sample. "PL" samples are from pine plantations, "UN" samples are from uninvaded eucalypt forests adjacent to invaded forests, and "INV" are from pine-invaded eucalypt forests.
In this figure, we can see that samples with lower bulk P also have higher abundances of genera in the yellow module, confirming the correlation between the yellow module and lower soil P. 

Now, to explore the other significant module, midnightblue, we do the same steps that we did with the yellow module but with %N as the trait of interest. 

```{r}
weight = as.data.frame(datTraits$percN); #Here, you can change to your trait of interest. We use soil P here.
names(weight) = "%N" 
# names (colors) of the modules
modNames = substring(names(MEs), 3)
geneModuleMembership = as.data.frame(cor(datExpr0, MEs, use = "p"));
MMPvalue = as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), nSamples));
names(geneModuleMembership) = paste("MM", modNames, sep="");
names(MMPvalue) = paste("p.MM", modNames, sep="");
geneTraitSignificance = as.data.frame(cor(datExpr0, weight, use = "p"));
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples));
names(geneTraitSignificance) = paste("GS.", names(weight), sep="");
names(GSPvalue) = paste("p.GS.", names(weight), sep="")
```


```{r}
module = "midnightblue" #*change this to the module we're going to look at
column = match(module, modNames);
moduleGenes = moduleColors==module;
par(mfrow = c(1,1));
verboseScatterplot(abs(geneModuleMembership[moduleGenes, column]),
                   abs(geneTraitSignificance[moduleGenes, 1]),
                   xlab = paste("ModMem in", module, "module"),
                   ylab = "Sig for %N",
                   main = paste("MM vs. GS\n"),
                   cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2, col = module)
```

Making VSD files by module - so we can tell what genera are in each module

```{r}
# vs=t(datExpr0)
# cands=names(datExpr0[moduleColors=="yellow"]) #change this to the color of the module we're looking at
# #subsetting the genes in this module
# c.vsd=vs[rownames(vs) %in% cands,]
# head(c.vsd)
# nrow(c.vsd) #should correspond to module size
# table(moduleColors) #check module sizes here
# head(c.vsd)
# write.csv(c.vsd,"rlog_MMmidnightblue.csv",quote=F)
```


```{r, warning = FALSE, message= FALSE}
setwd("/project/bi594/Pine_invasion/")
vsd <- read.csv("Invasion_wgcna_allgenes2.csv", row.names=1)
options(stringsAsFactors=FALSE)
data=t(vsd)
allkME =as.data.frame(signedKME(data, MEs))

```


```{r}
whichModule="midnightblue"

length(moduleColors)
inModule=data.frame("module"=rep(0,nrow(vsd)))
row.names(inModule)=row.names(vsd)
genes=row.names(vsd)[moduleColors == whichModule]
inModule[genes,1]=1
sum(inModule[,1]) #this should be the same number of genera that was in the module
```

```{r, eval=FALSE}
write.csv(inModule,file=paste(whichModule,"_fisher.csv",sep=""),quote=F)
```

```{r}
midnightblue <- subset(inModule, module=="1")
midnightblue <- row.names(midnightblue)
midnightblue
```

```{r}
modColName=paste("kME",whichModule,sep="")
modkME=as.data.frame(allkME[,modColName])
row.names(modkME)=row.names(allkME)
names(modkME)=modColName

```
```{r, eval=FALSE}
write.csv(modkME,file=paste(whichModule,"_kME.csv",sep=""),quote=F)
```

```{r}
mbkmeinput<- paste(midnightblue, sep=",")
mbkme<- subset(modkME, rownames(modkME) %in% mbkmeinput)
Genus <- rownames(mbkme)
rownames(mbkme) <- NULL
mbkme <- cbind(Genus,mbkme)
```

```{r}
ggplot(data= mbkme, aes(x=reorder(Genus, -kMEmidnightblue), y=kMEmidnightblue)) + 
  geom_bar(fill="midnightblue", stat="identity") +
  theme(axis.text.x=element_text(angle=45,hjust=1,vjust=1)) +
  labs(x="Genus", y="kME")
```


```{r}
which.module="midnightblue" #*change this also to the color of module we're looking at 
#pick module of interest
ME=MEs[, paste("ME",which.module, sep="")]
genes=datExpr0[,moduleColors==which.module ] #replace where says subgene below to plot all rather than just subset

#quartz()
# par(mfrow=c(2,1), mar=c(0.3, 5.5, 3, 2))
par(mfrow=c(2,1), mar=c(0.3, 5.5, 5, 2))
plotMat(t(scale(genes) ),nrgcols=30,rlabels=F, clabels=rownames(genes), rcols=which.module)
par(mar=c(5, 4.2, 0, 0.7))
barplot(ME, col=which.module, main="", cex.main=2,
        ylab="Eigengene abundances",xlab="sample")
```


```{r}
which.module="midnightblue" #pick module of interest
which.trait="percN" #change trait of interest here
datTraits=datTraits[order((datTraits$percN),decreasing=T),]#change trait of interest here

trait=datTraits[, paste(which.trait)]
genes=datExpr0[,moduleColors==which.module ] #replace where says subgene below to plot all rather than just subset
genes=genes[rownames(datTraits),]

#quartz()
par(mfrow=c(2,1), mar=c(0.3, 5.5, 3, 2))
plotMat(t(scale(genes) ),nrgcols=30,rlabels=F, clabels=rownames(genes), rcols=which.module)
par(mar=c(5, 4.2, 0, 0.7))
barplot(trait, col=which.module, main="", cex.main=2,
        ylab="%N",xlab="sample")#change trait of interest here
```

We additionally explored the midnight blue module what was significantly positively correlated with %C, but we discounted the correlation because it appears to be driven entirely by one outlier genus. 

#Figures 

```{r}
p <- ggplot(fulldf, aes(x = site_code, y=Abundance, fill=Class))+ 
  labs(x="Forest type", fill = "Class")
p + geom_bar(stat="identity", colour="black") +
  scale_x_discrete(labels=c('Invaded forest', 'Plantation', "Native forest"))
```
Figure 1: Barplot of taxa abundance by forest type. The x-axis displays the categorical variables of forest type. The y-axis is total abundance of taxonomic class. From this figure we can conclude in the pine invaded forests there is an overall trend towards both a lower total abundance of taxa and a lower diversity of taxa relative to the other two forest types. 

```{r}
p2 <- ggplot(fullguild, aes(x = site_code, y=Abundance, fill=trophicMode))+ 
  labs(x="Forest type", fill = "Trophic Mode")
p2 + geom_bar(stat="identity", colour="black") +
  scale_x_discrete(labels=c('Invaded forest', 'Plantation', "Native forest"))
```
Figure 2: Barplot of guild abundance by forest type. The x-axis displays the categorical variables of forest type. The y-axis is total abundance of taxonomic class. Functional groups seem to differ across forest types which can impact how fungi interact with soil nutrient and can impact soil nutrient condition associated with each forest type. 

```{r}
plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors), c("Dynamic Tree Cut", "Merged dynamic"), dendroLabels= FALSE, hang=0.03, addGuide= TRUE, guideHang=0.05)
```

```{r}
labeledHeatmap(Matrix = moduleTraitCor,
               xLabels = names(datTraits),
               yLabels = names(MEs),
               ySymbols = names(MEs),
               colorLabels = FALSE,
               colors = blueWhiteRed(50),
               textMatrix = textMatrix,
               setStdMargins = FALSE,
               cex.text = 0.5,
               zlim = c(-1,1),
               main = paste("Module-trait relationships"))
```

# Conclusion

In conclusion, we found that total N was positively correlated with one module of genera and total P was negatively correlated with another module of genera. With this analysis, we identified key fungal genera that are associated with high N and low P. Furthermore, abundance of the genera associated with low P varied with forest type, indicating that changes in fungal communities with pine invasion are related to changes in soil nutrients with pine invasion. 


